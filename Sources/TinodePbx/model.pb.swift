// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: model.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Authentication level
public enum Pbx_AuthLevel: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case none // = 0
  case anon // = 10
  case auth // = 20
  case root // = 30
  case UNRECOGNIZED(Int)

  public init() {
    self = .none
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 10: self = .anon
    case 20: self = .auth
    case 30: self = .root
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .none: return 0
    case .anon: return 10
    case .auth: return 20
    case .root: return 30
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Pbx_AuthLevel] = [
    .none,
    .anon,
    .auth,
    .root,
  ]

}

public enum Pbx_InfoNote: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// Invalid value. The name must be globally unique.
  case x1 // = 0
  case read // = 1
  case recv // = 2
  case kp // = 3
  case call // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .x1
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .x1
    case 1: self = .read
    case 2: self = .recv
    case 3: self = .kp
    case 4: self = .call
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .x1: return 0
    case .read: return 1
    case .recv: return 2
    case .kp: return 3
    case .call: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Pbx_InfoNote] = [
    .x1,
    .read,
    .recv,
    .kp,
    .call,
  ]

}

public enum Pbx_CallEvent: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// Invalid value. The name must be globally unique.
  case x2 // = 0
  case accept // = 1
  case answer // = 2
  case hangUp // = 3
  case iceCandidate // = 4
  case invite // = 5
  case offer // = 6
  case ringing // = 7
  case UNRECOGNIZED(Int)

  public init() {
    self = .x2
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .x2
    case 1: self = .accept
    case 2: self = .answer
    case 3: self = .hangUp
    case 4: self = .iceCandidate
    case 5: self = .invite
    case 6: self = .offer
    case 7: self = .ringing
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .x2: return 0
    case .accept: return 1
    case .answer: return 2
    case .hangUp: return 3
    case .iceCandidate: return 4
    case .invite: return 5
    case .offer: return 6
    case .ringing: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Pbx_CallEvent] = [
    .x2,
    .accept,
    .answer,
    .hangUp,
    .iceCandidate,
    .invite,
    .offer,
    .ringing,
  ]

}

/// Plugin response codes
public enum Pbx_RespCode: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// Instruct Tinode server to continue with default processing of the client request.
  case `continue` // = 0

  /// Drop the request as if the client did not send it
  case drop // = 1

  /// Send the the provided response to the client.
  case respond // = 2

  /// Replace client's original request with the provided request then continue with
  /// processing.
  case replace // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .continue
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .continue
    case 1: self = .drop
    case 2: self = .respond
    case 3: self = .replace
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .continue: return 0
    case .drop: return 1
    case .respond: return 2
    case .replace: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Pbx_RespCode] = [
    .continue,
    .drop,
    .respond,
    .replace,
  ]

}

public enum Pbx_Crud: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case create // = 0
  case update // = 1
  case delete // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .create
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .create
    case 1: self = .update
    case 2: self = .delete
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .create: return 0
    case .update: return 1
    case .delete: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Pbx_Crud] = [
    .create,
    .update,
    .delete,
  ]

}

/// Dummy placeholder message.
public struct Pbx_Unused: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Topic default access mode
public struct Pbx_DefaultAcsMode: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var auth: String = String()

  public var anon: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Actual access mode
public struct Pbx_AccessMode: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Access mode requested by the user
  public var want: String = String()

  /// Access mode granted to the user by the admin
  public var given: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// SetSub: payload in set.sub request to update current subscription or invite another user, {sub.what} == "sub"
public struct Pbx_SetSub: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// User affected by this request. Default (empty): current user
  public var userID: String = String()

  /// Access mode change, either Given or Want depending on context
  public var mode: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Credentials such as email or phone number
public struct Pbx_ClientCred: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Credential type, i.e. `email` or `tel`.
  public var method: String = String()

  /// Value to verify, i.e. `user@example.com` or `+18003287448`
  public var value: String = String()

  /// Verification response
  public var response: String = String()

  /// Request parameters, such as preferences or country code.
  public var params: Dictionary<String,Data> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// SetDesc: C2S in set.what == "desc" and sub.init message
public struct Pbx_SetDesc: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var defaultAcs: Pbx_DefaultAcsMode {
    get {return _defaultAcs ?? Pbx_DefaultAcsMode()}
    set {_defaultAcs = newValue}
  }
  /// Returns true if `defaultAcs` has been explicitly set.
  public var hasDefaultAcs: Bool {return self._defaultAcs != nil}
  /// Clears the value of `defaultAcs`. Subsequent reads from it will return its default value.
  public mutating func clearDefaultAcs() {self._defaultAcs = nil}

  public var `public`: Data = Data()

  public var `private`: Data = Data()

  public var trusted: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _defaultAcs: Pbx_DefaultAcsMode? = nil
}

public struct Pbx_GetOpts: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Timestamp in milliseconds since epoch 01/01/1970
  public var ifModifiedSince: Int64 = 0

  /// Limit search to this user ID
  public var user: String = String()

  /// Limit search results to one topic;
  public var topic: String = String()

  /// Load messages with seq id equal or greater than this
  public var sinceID: Int32 = 0

  /// Load messages with seq id lower than this
  public var beforeID: Int32 = 0

  /// Maximum number of results to return
  public var limit: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pbx_GetQuery: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var what: String {
    get {return _storage._what}
    set {_uniqueStorage()._what = newValue}
  }

  /// Parameters of "desc" request
  public var desc: Pbx_GetOpts {
    get {return _storage._desc ?? Pbx_GetOpts()}
    set {_uniqueStorage()._desc = newValue}
  }
  /// Returns true if `desc` has been explicitly set.
  public var hasDesc: Bool {return _storage._desc != nil}
  /// Clears the value of `desc`. Subsequent reads from it will return its default value.
  public mutating func clearDesc() {_uniqueStorage()._desc = nil}

  /// Parameters of "sub" request
  public var sub: Pbx_GetOpts {
    get {return _storage._sub ?? Pbx_GetOpts()}
    set {_uniqueStorage()._sub = newValue}
  }
  /// Returns true if `sub` has been explicitly set.
  public var hasSub: Bool {return _storage._sub != nil}
  /// Clears the value of `sub`. Subsequent reads from it will return its default value.
  public mutating func clearSub() {_uniqueStorage()._sub = nil}

  /// Parameters of "data" request
  public var data: Pbx_GetOpts {
    get {return _storage._data ?? Pbx_GetOpts()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Pbx_SetQuery: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Topic metadata, new topic & new subscriptions only
  public var desc: Pbx_SetDesc {
    get {return _desc ?? Pbx_SetDesc()}
    set {_desc = newValue}
  }
  /// Returns true if `desc` has been explicitly set.
  public var hasDesc: Bool {return self._desc != nil}
  /// Clears the value of `desc`. Subsequent reads from it will return its default value.
  public mutating func clearDesc() {self._desc = nil}

  /// Subscription parameters
  public var sub: Pbx_SetSub {
    get {return _sub ?? Pbx_SetSub()}
    set {_sub = newValue}
  }
  /// Returns true if `sub` has been explicitly set.
  public var hasSub: Bool {return self._sub != nil}
  /// Clears the value of `sub`. Subsequent reads from it will return its default value.
  public mutating func clearSub() {self._sub = nil}

  /// Indexable tags
  public var tags: [String] = []

  /// Credential being updated.
  public var cred: Pbx_ClientCred {
    get {return _cred ?? Pbx_ClientCred()}
    set {_cred = newValue}
  }
  /// Returns true if `cred` has been explicitly set.
  public var hasCred: Bool {return self._cred != nil}
  /// Clears the value of `cred`. Subsequent reads from it will return its default value.
  public mutating func clearCred() {self._cred = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _desc: Pbx_SetDesc? = nil
  fileprivate var _sub: Pbx_SetSub? = nil
  fileprivate var _cred: Pbx_ClientCred? = nil
}

public struct Pbx_SeqRange: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var low: Int32 = 0

  public var hi: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Client handshake
public struct Pbx_ClientHi: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var userAgent: String = String()

  public var ver: String = String()

  public var deviceID: String = String()

  public var lang: String = String()

  public var platform: String = String()

  public var background: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// User creation message {acc}
public struct Pbx_ClientAcc: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// User being created or updated
  public var userID: String {
    get {return _storage._userID}
    set {_uniqueStorage()._userID = newValue}
  }

  /// The initial authentication scheme the account can use
  public var scheme: String {
    get {return _storage._scheme}
    set {_uniqueStorage()._scheme = newValue}
  }

  /// Shared secret
  public var secret: Data {
    get {return _storage._secret}
    set {_uniqueStorage()._secret = newValue}
  }

  /// Authenticate session with the newly created account
  public var login: Bool {
    get {return _storage._login}
    set {_uniqueStorage()._login = newValue}
  }

  /// Indexable tags for user discovery
  public var tags: [String] {
    get {return _storage._tags}
    set {_uniqueStorage()._tags = newValue}
  }

  /// User initialization data when creating a new user, otherwise ignored
  public var desc: Pbx_SetDesc {
    get {return _storage._desc ?? Pbx_SetDesc()}
    set {_uniqueStorage()._desc = newValue}
  }
  /// Returns true if `desc` has been explicitly set.
  public var hasDesc: Bool {return _storage._desc != nil}
  /// Clears the value of `desc`. Subsequent reads from it will return its default value.
  public mutating func clearDesc() {_uniqueStorage()._desc = nil}

  /// Credentials for verification.
  public var cred: [Pbx_ClientCred] {
    get {return _storage._cred}
    set {_uniqueStorage()._cred = newValue}
  }

  /// Authentication token used for resetting a password.
  public var token: Data {
    get {return _storage._token}
    set {_uniqueStorage()._token = newValue}
  }

  /// Account state: normal ("ok"), suspended
  public var state: String {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  /// AuthLevel
  public var authLevel: Pbx_AuthLevel {
    get {return _storage._authLevel}
    set {_uniqueStorage()._authLevel = newValue}
  }

  /// Temporary auth params for one-off actions like password reset.
  public var tmpScheme: String {
    get {return _storage._tmpScheme}
    set {_uniqueStorage()._tmpScheme = newValue}
  }

  public var tmpSecret: Data {
    get {return _storage._tmpSecret}
    set {_uniqueStorage()._tmpSecret = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Login {login} message
public struct Pbx_ClientLogin: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  /// Authentication scheme
  public var scheme: String = String()

  /// Shared secret
  public var secret: Data = Data()

  /// Credentials for verification.
  public var cred: [Pbx_ClientCred] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Subscription request {sub} message
public struct Pbx_ClientSub: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var topic: String = String()

  /// mirrors {set}
  public var setQuery: Pbx_SetQuery {
    get {return _setQuery ?? Pbx_SetQuery()}
    set {_setQuery = newValue}
  }
  /// Returns true if `setQuery` has been explicitly set.
  public var hasSetQuery: Bool {return self._setQuery != nil}
  /// Clears the value of `setQuery`. Subsequent reads from it will return its default value.
  public mutating func clearSetQuery() {self._setQuery = nil}

  /// mirrors {get}
  public var getQuery: Pbx_GetQuery {
    get {return _getQuery ?? Pbx_GetQuery()}
    set {_getQuery = newValue}
  }
  /// Returns true if `getQuery` has been explicitly set.
  public var hasGetQuery: Bool {return self._getQuery != nil}
  /// Clears the value of `getQuery`. Subsequent reads from it will return its default value.
  public mutating func clearGetQuery() {self._getQuery = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _setQuery: Pbx_SetQuery? = nil
  fileprivate var _getQuery: Pbx_GetQuery? = nil
}

/// Unsubscribe {leave} request message
public struct Pbx_ClientLeave: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var topic: String = String()

  public var unsub: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ClientPub is client's request to publish data to topic subscribers {pub}
public struct Pbx_ClientPub: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var topic: String = String()

  public var noEcho: Bool = false

  public var head: Dictionary<String,Data> = [:]

  public var content: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Query topic state {get}
public struct Pbx_ClientGet: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var topic: String = String()

  public var query: Pbx_GetQuery {
    get {return _query ?? Pbx_GetQuery()}
    set {_query = newValue}
  }
  /// Returns true if `query` has been explicitly set.
  public var hasQuery: Bool {return self._query != nil}
  /// Clears the value of `query`. Subsequent reads from it will return its default value.
  public mutating func clearQuery() {self._query = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _query: Pbx_GetQuery? = nil
}

/// Update topic state {set}
public struct Pbx_ClientSet: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var topic: String = String()

  public var query: Pbx_SetQuery {
    get {return _query ?? Pbx_SetQuery()}
    set {_query = newValue}
  }
  /// Returns true if `query` has been explicitly set.
  public var hasQuery: Bool {return self._query != nil}
  /// Clears the value of `query`. Subsequent reads from it will return its default value.
  public mutating func clearQuery() {self._query = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _query: Pbx_SetQuery? = nil
}

/// ClientDel delete messages or topic
public struct Pbx_ClientDel: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var topic: String = String()

  public var what: Pbx_ClientDel.What = .x0

  /// Delete messages by id or range of ids
  public var delSeq: [Pbx_SeqRange] = []

  /// User ID of the subscription to delete
  public var userID: String = String()

  /// Credential to delete.
  public var cred: Pbx_ClientCred {
    get {return _cred ?? Pbx_ClientCred()}
    set {_cred = newValue}
  }
  /// Returns true if `cred` has been explicitly set.
  public var hasCred: Bool {return self._cred != nil}
  /// Clears the value of `cred`. Subsequent reads from it will return its default value.
  public mutating func clearCred() {self._cred = nil}

  /// Request to hard-delete messages for all users, if such option is available.
  public var hard: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// What to delete, either "msg" to delete messages (default) or "topic" to delete the topic or "sub"
  /// to delete a subscription to topic.
  public enum What: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// Invalid value. The name must be globally unique.
    case x0 // = 0
    case msg // = 1
    case topic // = 2
    case sub // = 3
    case user // = 4
    case cred // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .x0
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .x0
      case 1: self = .msg
      case 2: self = .topic
      case 3: self = .sub
      case 4: self = .user
      case 5: self = .cred
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .x0: return 0
      case .msg: return 1
      case .topic: return 2
      case .sub: return 3
      case .user: return 4
      case .cred: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Pbx_ClientDel.What] = [
      .x0,
      .msg,
      .topic,
      .sub,
      .user,
      .cred,
    ]

  }

  public init() {}

  fileprivate var _cred: Pbx_ClientCred? = nil
}

/// ClientNote is a client-generated notification for topic subscribers
public struct Pbx_ClientNote: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var topic: String = String()

  /// what is being reported: "recv" - message received, "read" - message read,
  /// "kp" - typing notification, "call" - voice/video call
  public var what: Pbx_InfoNote = .x1

  /// Server-issued message ID being reported
  public var seqID: Int32 = 0

  /// Client's count of unread messages to report back to the server. Used in push notifications on iOS.
  public var unread: Int32 = 0

  /// Call event.
  public var event: Pbx_CallEvent = .x2

  /// Arbitrary json payload (used in video calls).
  public var payload: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pbx_ClientExtra: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var attachments: [String] = []

  /// Root user may send messages on behalf of other users.
  public var onBehalfOf: String = String()

  public var authLevel: Pbx_AuthLevel = .none

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pbx_ClientMsg: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var message: OneOf_Message? {
    get {return _storage._message}
    set {_uniqueStorage()._message = newValue}
  }

  public var hi: Pbx_ClientHi {
    get {
      if case .hi(let v)? = _storage._message {return v}
      return Pbx_ClientHi()
    }
    set {_uniqueStorage()._message = .hi(newValue)}
  }

  public var acc: Pbx_ClientAcc {
    get {
      if case .acc(let v)? = _storage._message {return v}
      return Pbx_ClientAcc()
    }
    set {_uniqueStorage()._message = .acc(newValue)}
  }

  public var login: Pbx_ClientLogin {
    get {
      if case .login(let v)? = _storage._message {return v}
      return Pbx_ClientLogin()
    }
    set {_uniqueStorage()._message = .login(newValue)}
  }

  public var sub: Pbx_ClientSub {
    get {
      if case .sub(let v)? = _storage._message {return v}
      return Pbx_ClientSub()
    }
    set {_uniqueStorage()._message = .sub(newValue)}
  }

  public var leave: Pbx_ClientLeave {
    get {
      if case .leave(let v)? = _storage._message {return v}
      return Pbx_ClientLeave()
    }
    set {_uniqueStorage()._message = .leave(newValue)}
  }

  public var pub: Pbx_ClientPub {
    get {
      if case .pub(let v)? = _storage._message {return v}
      return Pbx_ClientPub()
    }
    set {_uniqueStorage()._message = .pub(newValue)}
  }

  public var get: Pbx_ClientGet {
    get {
      if case .get(let v)? = _storage._message {return v}
      return Pbx_ClientGet()
    }
    set {_uniqueStorage()._message = .get(newValue)}
  }

  public var set: Pbx_ClientSet {
    get {
      if case .set(let v)? = _storage._message {return v}
      return Pbx_ClientSet()
    }
    set {_uniqueStorage()._message = .set(newValue)}
  }

  public var del: Pbx_ClientDel {
    get {
      if case .del(let v)? = _storage._message {return v}
      return Pbx_ClientDel()
    }
    set {_uniqueStorage()._message = .del(newValue)}
  }

  public var note: Pbx_ClientNote {
    get {
      if case .note(let v)? = _storage._message {return v}
      return Pbx_ClientNote()
    }
    set {_uniqueStorage()._message = .note(newValue)}
  }

  /// Additional message parameters.
  public var extra: Pbx_ClientExtra {
    get {return _storage._extra ?? Pbx_ClientExtra()}
    set {_uniqueStorage()._extra = newValue}
  }
  /// Returns true if `extra` has been explicitly set.
  public var hasExtra: Bool {return _storage._extra != nil}
  /// Clears the value of `extra`. Subsequent reads from it will return its default value.
  public mutating func clearExtra() {_uniqueStorage()._extra = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Message: Equatable, Sendable {
    case hi(Pbx_ClientHi)
    case acc(Pbx_ClientAcc)
    case login(Pbx_ClientLogin)
    case sub(Pbx_ClientSub)
    case leave(Pbx_ClientLeave)
    case pub(Pbx_ClientPub)
    case get(Pbx_ClientGet)
    case set(Pbx_ClientSet)
    case del(Pbx_ClientDel)
    case note(Pbx_ClientNote)

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Credentials
public struct Pbx_ServerCred: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Credential type, i.e. `email` or `tel`.
  public var method: String = String()

  /// Value to verify, i.e. `user@example.com` or `+18003287448`
  public var value: String = String()

  /// Indicator that the credential is validated
  public var done: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Topic description, S2C in Meta message
public struct Pbx_TopicDesc: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var createdAt: Int64 {
    get {return _storage._createdAt}
    set {_uniqueStorage()._createdAt = newValue}
  }

  public var updatedAt: Int64 {
    get {return _storage._updatedAt}
    set {_uniqueStorage()._updatedAt = newValue}
  }

  public var touchedAt: Int64 {
    get {return _storage._touchedAt}
    set {_uniqueStorage()._touchedAt = newValue}
  }

  public var defacs: Pbx_DefaultAcsMode {
    get {return _storage._defacs ?? Pbx_DefaultAcsMode()}
    set {_uniqueStorage()._defacs = newValue}
  }
  /// Returns true if `defacs` has been explicitly set.
  public var hasDefacs: Bool {return _storage._defacs != nil}
  /// Clears the value of `defacs`. Subsequent reads from it will return its default value.
  public mutating func clearDefacs() {_uniqueStorage()._defacs = nil}

  public var acs: Pbx_AccessMode {
    get {return _storage._acs ?? Pbx_AccessMode()}
    set {_uniqueStorage()._acs = newValue}
  }
  /// Returns true if `acs` has been explicitly set.
  public var hasAcs: Bool {return _storage._acs != nil}
  /// Clears the value of `acs`. Subsequent reads from it will return its default value.
  public mutating func clearAcs() {_uniqueStorage()._acs = nil}

  public var seqID: Int32 {
    get {return _storage._seqID}
    set {_uniqueStorage()._seqID = newValue}
  }

  public var readID: Int32 {
    get {return _storage._readID}
    set {_uniqueStorage()._readID = newValue}
  }

  public var recvID: Int32 {
    get {return _storage._recvID}
    set {_uniqueStorage()._recvID = newValue}
  }

  public var delID: Int32 {
    get {return _storage._delID}
    set {_uniqueStorage()._delID = newValue}
  }

  public var `public`: Data {
    get {return _storage._public}
    set {_uniqueStorage()._public = newValue}
  }

  public var `private`: Data {
    get {return _storage._private}
    set {_uniqueStorage()._private = newValue}
  }

  public var state: String {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  public var stateAt: Int64 {
    get {return _storage._stateAt}
    set {_uniqueStorage()._stateAt = newValue}
  }

  public var trusted: Data {
    get {return _storage._trusted}
    set {_uniqueStorage()._trusted = newValue}
  }

  /// 17!
  public var isChan: Bool {
    get {return _storage._isChan}
    set {_uniqueStorage()._isChan = newValue}
  }

  public var online: Bool {
    get {return _storage._online}
    set {_uniqueStorage()._online = newValue}
  }

  /// P2P only: other user's last online timestamp & user agent
  public var lastSeenTime: Int64 {
    get {return _storage._lastSeenTime}
    set {_uniqueStorage()._lastSeenTime = newValue}
  }

  public var lastSeenUserAgent: String {
    get {return _storage._lastSeenUserAgent}
    set {_uniqueStorage()._lastSeenUserAgent = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// MsgTopicSub: topic subscription details, sent in Meta message
public struct Pbx_TopicSub: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var updatedAt: Int64 {
    get {return _storage._updatedAt}
    set {_uniqueStorage()._updatedAt = newValue}
  }

  public var deletedAt: Int64 {
    get {return _storage._deletedAt}
    set {_uniqueStorage()._deletedAt = newValue}
  }

  public var online: Bool {
    get {return _storage._online}
    set {_uniqueStorage()._online = newValue}
  }

  public var acs: Pbx_AccessMode {
    get {return _storage._acs ?? Pbx_AccessMode()}
    set {_uniqueStorage()._acs = newValue}
  }
  /// Returns true if `acs` has been explicitly set.
  public var hasAcs: Bool {return _storage._acs != nil}
  /// Clears the value of `acs`. Subsequent reads from it will return its default value.
  public mutating func clearAcs() {_uniqueStorage()._acs = nil}

  public var readID: Int32 {
    get {return _storage._readID}
    set {_uniqueStorage()._readID = newValue}
  }

  public var recvID: Int32 {
    get {return _storage._recvID}
    set {_uniqueStorage()._recvID = newValue}
  }

  public var `public`: Data {
    get {return _storage._public}
    set {_uniqueStorage()._public = newValue}
  }

  /// 16!
  public var trusted: Data {
    get {return _storage._trusted}
    set {_uniqueStorage()._trusted = newValue}
  }

  public var `private`: Data {
    get {return _storage._private}
    set {_uniqueStorage()._private = newValue}
  }

  /// Uid of the subscribed user
  public var userID: String {
    get {return _storage._userID}
    set {_uniqueStorage()._userID = newValue}
  }

  /// Topic name of this subscription
  public var topic: String {
    get {return _storage._topic}
    set {_uniqueStorage()._topic = newValue}
  }

  public var touchedAt: Int64 {
    get {return _storage._touchedAt}
    set {_uniqueStorage()._touchedAt = newValue}
  }

  /// ID of the last {data} message in a topic
  public var seqID: Int32 {
    get {return _storage._seqID}
    set {_uniqueStorage()._seqID = newValue}
  }

  /// Messages are deleted up to this ID
  public var delID: Int32 {
    get {return _storage._delID}
    set {_uniqueStorage()._delID = newValue}
  }

  /// Other user's last online timestamp & user agent
  public var lastSeenTime: Int64 {
    get {return _storage._lastSeenTime}
    set {_uniqueStorage()._lastSeenTime = newValue}
  }

  public var lastSeenUserAgent: String {
    get {return _storage._lastSeenUserAgent}
    set {_uniqueStorage()._lastSeenUserAgent = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Pbx_DelValues: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var delID: Int32 = 0

  public var delSeq: [Pbx_SeqRange] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// {ctrl} message
public struct Pbx_ServerCtrl: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var topic: String = String()

  public var code: Int32 = 0

  public var text: String = String()

  public var params: Dictionary<String,Data> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// {data} message
public struct Pbx_ServerData: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var topic: String = String()

  /// ID of the user who originated the message as {pub}, could be empty if sent by the system
  public var fromUserID: String = String()

  /// Timestamp when the message was sent.
  public var timestamp: Int64 = 0

  /// Timestamp when the message was deleted or 0. Milliseconds since the epoch 01/01/1970
  public var deletedAt: Int64 = 0

  public var seqID: Int32 = 0

  public var head: Dictionary<String,Data> = [:]

  public var content: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// {pres} message
public struct Pbx_ServerPres: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var topic: String = String()

  public var src: String = String()

  public var what: Pbx_ServerPres.What = .x3

  public var userAgent: String = String()

  public var seqID: Int32 = 0

  public var delID: Int32 = 0

  public var delSeq: [Pbx_SeqRange] = []

  public var targetUserID: String = String()

  public var actorUserID: String = String()

  public var acs: Pbx_AccessMode {
    get {return _acs ?? Pbx_AccessMode()}
    set {_acs = newValue}
  }
  /// Returns true if `acs` has been explicitly set.
  public var hasAcs: Bool {return self._acs != nil}
  /// Clears the value of `acs`. Subsequent reads from it will return its default value.
  public mutating func clearAcs() {self._acs = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum What: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// Invalid value. The name must be globally unique.
    case x3 // = 0
    case on // = 1
    case off // = 2
    case ua // = 3
    case upd // = 4
    case gone // = 5
    case acs // = 6
    case term // = 7
    case msg // = 8
    case read // = 9
    case recv // = 10
    case del // = 11
    case tags // = 12
    case UNRECOGNIZED(Int)

    public init() {
      self = .x3
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .x3
      case 1: self = .on
      case 2: self = .off
      case 3: self = .ua
      case 4: self = .upd
      case 5: self = .gone
      case 6: self = .acs
      case 7: self = .term
      case 8: self = .msg
      case 9: self = .read
      case 10: self = .recv
      case 11: self = .del
      case 12: self = .tags
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .x3: return 0
      case .on: return 1
      case .off: return 2
      case .ua: return 3
      case .upd: return 4
      case .gone: return 5
      case .acs: return 6
      case .term: return 7
      case .msg: return 8
      case .read: return 9
      case .recv: return 10
      case .del: return 11
      case .tags: return 12
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Pbx_ServerPres.What] = [
      .x3,
      .on,
      .off,
      .ua,
      .upd,
      .gone,
      .acs,
      .term,
      .msg,
      .read,
      .recv,
      .del,
      .tags,
    ]

  }

  public init() {}

  fileprivate var _acs: Pbx_AccessMode? = nil
}

/// {meta} message
public struct Pbx_ServerMeta: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var topic: String = String()

  public var desc: Pbx_TopicDesc {
    get {return _desc ?? Pbx_TopicDesc()}
    set {_desc = newValue}
  }
  /// Returns true if `desc` has been explicitly set.
  public var hasDesc: Bool {return self._desc != nil}
  /// Clears the value of `desc`. Subsequent reads from it will return its default value.
  public mutating func clearDesc() {self._desc = nil}

  public var sub: [Pbx_TopicSub] = []

  public var del: Pbx_DelValues {
    get {return _del ?? Pbx_DelValues()}
    set {_del = newValue}
  }
  /// Returns true if `del` has been explicitly set.
  public var hasDel: Bool {return self._del != nil}
  /// Clears the value of `del`. Subsequent reads from it will return its default value.
  public mutating func clearDel() {self._del = nil}

  public var tags: [String] = []

  public var cred: [Pbx_ServerCred] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _desc: Pbx_TopicDesc? = nil
  fileprivate var _del: Pbx_DelValues? = nil
}

/// {info} message: server-side copy of ClientNote with From and optional Src added.
public struct Pbx_ServerInfo: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var topic: String = String()

  public var fromUserID: String = String()

  public var what: Pbx_InfoNote = .x1

  public var seqID: Int32 = 0

  public var src: String = String()

  public var event: Pbx_CallEvent = .x2

  public var payload: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Cumulative message
public struct Pbx_ServerMsg: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var message: Pbx_ServerMsg.OneOf_Message? = nil

  public var ctrl: Pbx_ServerCtrl {
    get {
      if case .ctrl(let v)? = message {return v}
      return Pbx_ServerCtrl()
    }
    set {message = .ctrl(newValue)}
  }

  public var data: Pbx_ServerData {
    get {
      if case .data(let v)? = message {return v}
      return Pbx_ServerData()
    }
    set {message = .data(newValue)}
  }

  public var pres: Pbx_ServerPres {
    get {
      if case .pres(let v)? = message {return v}
      return Pbx_ServerPres()
    }
    set {message = .pres(newValue)}
  }

  public var meta: Pbx_ServerMeta {
    get {
      if case .meta(let v)? = message {return v}
      return Pbx_ServerMeta()
    }
    set {message = .meta(newValue)}
  }

  public var info: Pbx_ServerInfo {
    get {
      if case .info(let v)? = message {return v}
      return Pbx_ServerInfo()
    }
    set {message = .info(newValue)}
  }

  /// DEPRECATED. Will be removed soon.
  /// When response is sent to Root, send internal topic name too.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  public var topic: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Message: Equatable, Sendable {
    case ctrl(Pbx_ServerCtrl)
    case data(Pbx_ServerData)
    case pres(Pbx_ServerPres)
    case meta(Pbx_ServerMeta)
    case info(Pbx_ServerInfo)

  }

  public init() {}
}

public struct Pbx_ServerResp: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Pbx_RespCode = .continue

  public var srvmsg: Pbx_ServerMsg {
    get {return _srvmsg ?? Pbx_ServerMsg()}
    set {_srvmsg = newValue}
  }
  /// Returns true if `srvmsg` has been explicitly set.
  public var hasSrvmsg: Bool {return self._srvmsg != nil}
  /// Clears the value of `srvmsg`. Subsequent reads from it will return its default value.
  public mutating func clearSrvmsg() {self._srvmsg = nil}

  public var clmsg: Pbx_ClientMsg {
    get {return _clmsg ?? Pbx_ClientMsg()}
    set {_clmsg = newValue}
  }
  /// Returns true if `clmsg` has been explicitly set.
  public var hasClmsg: Bool {return self._clmsg != nil}
  /// Clears the value of `clmsg`. Subsequent reads from it will return its default value.
  public mutating func clearClmsg() {self._clmsg = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _srvmsg: Pbx_ServerMsg? = nil
  fileprivate var _clmsg: Pbx_ClientMsg? = nil
}

/// Context message
public struct Pbx_Session: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sessionID: String = String()

  public var userID: String = String()

  public var authLevel: Pbx_AuthLevel = .none

  public var remoteAddr: String = String()

  public var userAgent: String = String()

  public var deviceID: String = String()

  public var language: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pbx_ClientReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var msg: Pbx_ClientMsg {
    get {return _msg ?? Pbx_ClientMsg()}
    set {_msg = newValue}
  }
  /// Returns true if `msg` has been explicitly set.
  public var hasMsg: Bool {return self._msg != nil}
  /// Clears the value of `msg`. Subsequent reads from it will return its default value.
  public mutating func clearMsg() {self._msg = nil}

  public var sess: Pbx_Session {
    get {return _sess ?? Pbx_Session()}
    set {_sess = newValue}
  }
  /// Returns true if `sess` has been explicitly set.
  public var hasSess: Bool {return self._sess != nil}
  /// Clears the value of `sess`. Subsequent reads from it will return its default value.
  public mutating func clearSess() {self._sess = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _msg: Pbx_ClientMsg? = nil
  fileprivate var _sess: Pbx_Session? = nil
}

public struct Pbx_SearchQuery: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: String = String()

  public var query: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pbx_SearchFound: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Pbx_RespCode = .continue

  /// New search query If status == REPLACE, otherwise unset.
  public var query: String = String()

  /// Search results.
  public var result: [Pbx_TopicSub] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pbx_TopicEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var action: Pbx_Crud = .create

  public var name: String = String()

  public var desc: Pbx_TopicDesc {
    get {return _desc ?? Pbx_TopicDesc()}
    set {_desc = newValue}
  }
  /// Returns true if `desc` has been explicitly set.
  public var hasDesc: Bool {return self._desc != nil}
  /// Clears the value of `desc`. Subsequent reads from it will return its default value.
  public mutating func clearDesc() {self._desc = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _desc: Pbx_TopicDesc? = nil
}

public struct Pbx_AccountEvent: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var action: Pbx_Crud = .create

  public var userID: String = String()

  public var defaultAcs: Pbx_DefaultAcsMode {
    get {return _defaultAcs ?? Pbx_DefaultAcsMode()}
    set {_defaultAcs = newValue}
  }
  /// Returns true if `defaultAcs` has been explicitly set.
  public var hasDefaultAcs: Bool {return self._defaultAcs != nil}
  /// Clears the value of `defaultAcs`. Subsequent reads from it will return its default value.
  public mutating func clearDefaultAcs() {self._defaultAcs = nil}

  public var `public`: Data = Data()

  /// Indexable tags for user discovery
  public var tags: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _defaultAcs: Pbx_DefaultAcsMode? = nil
}

public struct Pbx_SubscriptionEvent: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var action: Pbx_Crud = .create

  public var topic: String = String()

  public var userID: String = String()

  public var delID: Int32 = 0

  public var readID: Int32 = 0

  public var recvID: Int32 = 0

  public var mode: Pbx_AccessMode {
    get {return _mode ?? Pbx_AccessMode()}
    set {_mode = newValue}
  }
  /// Returns true if `mode` has been explicitly set.
  public var hasMode: Bool {return self._mode != nil}
  /// Clears the value of `mode`. Subsequent reads from it will return its default value.
  public mutating func clearMode() {self._mode = nil}

  public var `private`: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _mode: Pbx_AccessMode? = nil
}

public struct Pbx_MessageEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var action: Pbx_Crud = .create

  public var msg: Pbx_ServerData {
    get {return _msg ?? Pbx_ServerData()}
    set {_msg = newValue}
  }
  /// Returns true if `msg` has been explicitly set.
  public var hasMsg: Bool {return self._msg != nil}
  /// Clears the value of `msg`. Subsequent reads from it will return its default value.
  public mutating func clearMsg() {self._msg = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _msg: Pbx_ServerData? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "pbx"

extension Pbx_AuthLevel: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    10: .same(proto: "ANON"),
    20: .same(proto: "AUTH"),
    30: .same(proto: "ROOT"),
  ]
}

extension Pbx_InfoNote: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "X1"),
    1: .same(proto: "READ"),
    2: .same(proto: "RECV"),
    3: .same(proto: "KP"),
    4: .same(proto: "CALL"),
  ]
}

extension Pbx_CallEvent: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "X2"),
    1: .same(proto: "ACCEPT"),
    2: .same(proto: "ANSWER"),
    3: .same(proto: "HANG_UP"),
    4: .same(proto: "ICE_CANDIDATE"),
    5: .same(proto: "INVITE"),
    6: .same(proto: "OFFER"),
    7: .same(proto: "RINGING"),
  ]
}

extension Pbx_RespCode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CONTINUE"),
    1: .same(proto: "DROP"),
    2: .same(proto: "RESPOND"),
    3: .same(proto: "REPLACE"),
  ]
}

extension Pbx_Crud: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CREATE"),
    1: .same(proto: "UPDATE"),
    2: .same(proto: "DELETE"),
  ]
}

extension Pbx_Unused: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Unused"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbx_Unused, rhs: Pbx_Unused) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbx_DefaultAcsMode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DefaultAcsMode"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "auth"),
    2: .same(proto: "anon"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.auth) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.anon) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.auth.isEmpty {
      try visitor.visitSingularStringField(value: self.auth, fieldNumber: 1)
    }
    if !self.anon.isEmpty {
      try visitor.visitSingularStringField(value: self.anon, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbx_DefaultAcsMode, rhs: Pbx_DefaultAcsMode) -> Bool {
    if lhs.auth != rhs.auth {return false}
    if lhs.anon != rhs.anon {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbx_AccessMode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccessMode"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "want"),
    2: .same(proto: "given"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.want) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.given) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.want.isEmpty {
      try visitor.visitSingularStringField(value: self.want, fieldNumber: 1)
    }
    if !self.given.isEmpty {
      try visitor.visitSingularStringField(value: self.given, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbx_AccessMode, rhs: Pbx_AccessMode) -> Bool {
    if lhs.want != rhs.want {return false}
    if lhs.given != rhs.given {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbx_SetSub: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetSub"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .same(proto: "mode"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.mode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if !self.mode.isEmpty {
      try visitor.visitSingularStringField(value: self.mode, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbx_SetSub, rhs: Pbx_SetSub) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.mode != rhs.mode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbx_ClientCred: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClientCred"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "method"),
    2: .same(proto: "value"),
    3: .same(proto: "response"),
    4: .same(proto: "params"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.method) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.response) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufBytes>.self, value: &self.params) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.method.isEmpty {
      try visitor.visitSingularStringField(value: self.method, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    if !self.response.isEmpty {
      try visitor.visitSingularStringField(value: self.response, fieldNumber: 3)
    }
    if !self.params.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufBytes>.self, value: self.params, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbx_ClientCred, rhs: Pbx_ClientCred) -> Bool {
    if lhs.method != rhs.method {return false}
    if lhs.value != rhs.value {return false}
    if lhs.response != rhs.response {return false}
    if lhs.params != rhs.params {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbx_SetDesc: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetDesc"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "default_acs"),
    2: .same(proto: "public"),
    3: .same(proto: "private"),
    4: .same(proto: "trusted"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._defaultAcs) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.`public`) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.`private`) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.trusted) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._defaultAcs {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.`public`.isEmpty {
      try visitor.visitSingularBytesField(value: self.`public`, fieldNumber: 2)
    }
    if !self.`private`.isEmpty {
      try visitor.visitSingularBytesField(value: self.`private`, fieldNumber: 3)
    }
    if !self.trusted.isEmpty {
      try visitor.visitSingularBytesField(value: self.trusted, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbx_SetDesc, rhs: Pbx_SetDesc) -> Bool {
    if lhs._defaultAcs != rhs._defaultAcs {return false}
    if lhs.`public` != rhs.`public` {return false}
    if lhs.`private` != rhs.`private` {return false}
    if lhs.trusted != rhs.trusted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbx_GetOpts: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetOpts"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "if_modified_since"),
    2: .same(proto: "user"),
    3: .same(proto: "topic"),
    4: .standard(proto: "since_id"),
    5: .standard(proto: "before_id"),
    6: .same(proto: "limit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.ifModifiedSince) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.user) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.topic) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.sinceID) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.beforeID) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.limit) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.ifModifiedSince != 0 {
      try visitor.visitSingularInt64Field(value: self.ifModifiedSince, fieldNumber: 1)
    }
    if !self.user.isEmpty {
      try visitor.visitSingularStringField(value: self.user, fieldNumber: 2)
    }
    if !self.topic.isEmpty {
      try visitor.visitSingularStringField(value: self.topic, fieldNumber: 3)
    }
    if self.sinceID != 0 {
      try visitor.visitSingularInt32Field(value: self.sinceID, fieldNumber: 4)
    }
    if self.beforeID != 0 {
      try visitor.visitSingularInt32Field(value: self.beforeID, fieldNumber: 5)
    }
    if self.limit != 0 {
      try visitor.visitSingularInt32Field(value: self.limit, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbx_GetOpts, rhs: Pbx_GetOpts) -> Bool {
    if lhs.ifModifiedSince != rhs.ifModifiedSince {return false}
    if lhs.user != rhs.user {return false}
    if lhs.topic != rhs.topic {return false}
    if lhs.sinceID != rhs.sinceID {return false}
    if lhs.beforeID != rhs.beforeID {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbx_GetQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetQuery"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "what"),
    2: .same(proto: "desc"),
    3: .same(proto: "sub"),
    4: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _what: String = String()
    var _desc: Pbx_GetOpts? = nil
    var _sub: Pbx_GetOpts? = nil
    var _data: Pbx_GetOpts? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _what = source._what
      _desc = source._desc
      _sub = source._sub
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._what) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._desc) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._sub) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._data) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._what.isEmpty {
        try visitor.visitSingularStringField(value: _storage._what, fieldNumber: 1)
      }
      try { if let v = _storage._desc {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._sub {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbx_GetQuery, rhs: Pbx_GetQuery) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._what != rhs_storage._what {return false}
        if _storage._desc != rhs_storage._desc {return false}
        if _storage._sub != rhs_storage._sub {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbx_SetQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetQuery"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "desc"),
    2: .same(proto: "sub"),
    3: .same(proto: "tags"),
    4: .same(proto: "cred"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._desc) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._sub) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.tags) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._cred) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._desc {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._sub {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.tags.isEmpty {
      try visitor.visitRepeatedStringField(value: self.tags, fieldNumber: 3)
    }
    try { if let v = self._cred {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbx_SetQuery, rhs: Pbx_SetQuery) -> Bool {
    if lhs._desc != rhs._desc {return false}
    if lhs._sub != rhs._sub {return false}
    if lhs.tags != rhs.tags {return false}
    if lhs._cred != rhs._cred {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbx_SeqRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SeqRange"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "low"),
    2: .same(proto: "hi"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.low) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.hi) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.low != 0 {
      try visitor.visitSingularInt32Field(value: self.low, fieldNumber: 1)
    }
    if self.hi != 0 {
      try visitor.visitSingularInt32Field(value: self.hi, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbx_SeqRange, rhs: Pbx_SeqRange) -> Bool {
    if lhs.low != rhs.low {return false}
    if lhs.hi != rhs.hi {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbx_ClientHi: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClientHi"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "user_agent"),
    3: .same(proto: "ver"),
    4: .standard(proto: "device_id"),
    5: .same(proto: "lang"),
    6: .same(proto: "platform"),
    7: .same(proto: "background"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.userAgent) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.ver) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.lang) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.platform) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.background) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.userAgent.isEmpty {
      try visitor.visitSingularStringField(value: self.userAgent, fieldNumber: 2)
    }
    if !self.ver.isEmpty {
      try visitor.visitSingularStringField(value: self.ver, fieldNumber: 3)
    }
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 4)
    }
    if !self.lang.isEmpty {
      try visitor.visitSingularStringField(value: self.lang, fieldNumber: 5)
    }
    if !self.platform.isEmpty {
      try visitor.visitSingularStringField(value: self.platform, fieldNumber: 6)
    }
    if self.background != false {
      try visitor.visitSingularBoolField(value: self.background, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbx_ClientHi, rhs: Pbx_ClientHi) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.userAgent != rhs.userAgent {return false}
    if lhs.ver != rhs.ver {return false}
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.lang != rhs.lang {return false}
    if lhs.platform != rhs.platform {return false}
    if lhs.background != rhs.background {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbx_ClientAcc: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClientAcc"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "user_id"),
    3: .same(proto: "scheme"),
    4: .same(proto: "secret"),
    5: .same(proto: "login"),
    6: .same(proto: "tags"),
    7: .same(proto: "desc"),
    8: .same(proto: "cred"),
    9: .same(proto: "token"),
    10: .same(proto: "state"),
    11: .standard(proto: "auth_level"),
    12: .standard(proto: "tmp_scheme"),
    13: .standard(proto: "tmp_secret"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _userID: String = String()
    var _scheme: String = String()
    var _secret: Data = Data()
    var _login: Bool = false
    var _tags: [String] = []
    var _desc: Pbx_SetDesc? = nil
    var _cred: [Pbx_ClientCred] = []
    var _token: Data = Data()
    var _state: String = String()
    var _authLevel: Pbx_AuthLevel = .none
    var _tmpScheme: String = String()
    var _tmpSecret: Data = Data()

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _userID = source._userID
      _scheme = source._scheme
      _secret = source._secret
      _login = source._login
      _tags = source._tags
      _desc = source._desc
      _cred = source._cred
      _token = source._token
      _state = source._state
      _authLevel = source._authLevel
      _tmpScheme = source._tmpScheme
      _tmpSecret = source._tmpSecret
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._userID) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._scheme) }()
        case 4: try { try decoder.decodeSingularBytesField(value: &_storage._secret) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._login) }()
        case 6: try { try decoder.decodeRepeatedStringField(value: &_storage._tags) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._desc) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._cred) }()
        case 9: try { try decoder.decodeSingularBytesField(value: &_storage._token) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._state) }()
        case 11: try { try decoder.decodeSingularEnumField(value: &_storage._authLevel) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._tmpScheme) }()
        case 13: try { try decoder.decodeSingularBytesField(value: &_storage._tmpSecret) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._userID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._userID, fieldNumber: 2)
      }
      if !_storage._scheme.isEmpty {
        try visitor.visitSingularStringField(value: _storage._scheme, fieldNumber: 3)
      }
      if !_storage._secret.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._secret, fieldNumber: 4)
      }
      if _storage._login != false {
        try visitor.visitSingularBoolField(value: _storage._login, fieldNumber: 5)
      }
      if !_storage._tags.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._tags, fieldNumber: 6)
      }
      try { if let v = _storage._desc {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if !_storage._cred.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._cred, fieldNumber: 8)
      }
      if !_storage._token.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._token, fieldNumber: 9)
      }
      if !_storage._state.isEmpty {
        try visitor.visitSingularStringField(value: _storage._state, fieldNumber: 10)
      }
      if _storage._authLevel != .none {
        try visitor.visitSingularEnumField(value: _storage._authLevel, fieldNumber: 11)
      }
      if !_storage._tmpScheme.isEmpty {
        try visitor.visitSingularStringField(value: _storage._tmpScheme, fieldNumber: 12)
      }
      if !_storage._tmpSecret.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._tmpSecret, fieldNumber: 13)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbx_ClientAcc, rhs: Pbx_ClientAcc) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._userID != rhs_storage._userID {return false}
        if _storage._scheme != rhs_storage._scheme {return false}
        if _storage._secret != rhs_storage._secret {return false}
        if _storage._login != rhs_storage._login {return false}
        if _storage._tags != rhs_storage._tags {return false}
        if _storage._desc != rhs_storage._desc {return false}
        if _storage._cred != rhs_storage._cred {return false}
        if _storage._token != rhs_storage._token {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._authLevel != rhs_storage._authLevel {return false}
        if _storage._tmpScheme != rhs_storage._tmpScheme {return false}
        if _storage._tmpSecret != rhs_storage._tmpSecret {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbx_ClientLogin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClientLogin"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "scheme"),
    3: .same(proto: "secret"),
    4: .same(proto: "cred"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.scheme) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.secret) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.cred) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.scheme.isEmpty {
      try visitor.visitSingularStringField(value: self.scheme, fieldNumber: 2)
    }
    if !self.secret.isEmpty {
      try visitor.visitSingularBytesField(value: self.secret, fieldNumber: 3)
    }
    if !self.cred.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cred, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbx_ClientLogin, rhs: Pbx_ClientLogin) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.scheme != rhs.scheme {return false}
    if lhs.secret != rhs.secret {return false}
    if lhs.cred != rhs.cred {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbx_ClientSub: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClientSub"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "topic"),
    3: .standard(proto: "set_query"),
    4: .standard(proto: "get_query"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.topic) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._setQuery) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._getQuery) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.topic.isEmpty {
      try visitor.visitSingularStringField(value: self.topic, fieldNumber: 2)
    }
    try { if let v = self._setQuery {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._getQuery {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbx_ClientSub, rhs: Pbx_ClientSub) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.topic != rhs.topic {return false}
    if lhs._setQuery != rhs._setQuery {return false}
    if lhs._getQuery != rhs._getQuery {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbx_ClientLeave: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClientLeave"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "topic"),
    3: .same(proto: "unsub"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.topic) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.unsub) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.topic.isEmpty {
      try visitor.visitSingularStringField(value: self.topic, fieldNumber: 2)
    }
    if self.unsub != false {
      try visitor.visitSingularBoolField(value: self.unsub, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbx_ClientLeave, rhs: Pbx_ClientLeave) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.topic != rhs.topic {return false}
    if lhs.unsub != rhs.unsub {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbx_ClientPub: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClientPub"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "topic"),
    3: .standard(proto: "no_echo"),
    4: .same(proto: "head"),
    5: .same(proto: "content"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.topic) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.noEcho) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufBytes>.self, value: &self.head) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.content) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.topic.isEmpty {
      try visitor.visitSingularStringField(value: self.topic, fieldNumber: 2)
    }
    if self.noEcho != false {
      try visitor.visitSingularBoolField(value: self.noEcho, fieldNumber: 3)
    }
    if !self.head.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufBytes>.self, value: self.head, fieldNumber: 4)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularBytesField(value: self.content, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbx_ClientPub, rhs: Pbx_ClientPub) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.topic != rhs.topic {return false}
    if lhs.noEcho != rhs.noEcho {return false}
    if lhs.head != rhs.head {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbx_ClientGet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClientGet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "topic"),
    3: .same(proto: "query"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.topic) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._query) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.topic.isEmpty {
      try visitor.visitSingularStringField(value: self.topic, fieldNumber: 2)
    }
    try { if let v = self._query {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbx_ClientGet, rhs: Pbx_ClientGet) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.topic != rhs.topic {return false}
    if lhs._query != rhs._query {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbx_ClientSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClientSet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "topic"),
    3: .same(proto: "query"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.topic) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._query) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.topic.isEmpty {
      try visitor.visitSingularStringField(value: self.topic, fieldNumber: 2)
    }
    try { if let v = self._query {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbx_ClientSet, rhs: Pbx_ClientSet) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.topic != rhs.topic {return false}
    if lhs._query != rhs._query {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbx_ClientDel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClientDel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "topic"),
    3: .same(proto: "what"),
    4: .standard(proto: "del_seq"),
    5: .standard(proto: "user_id"),
    6: .same(proto: "cred"),
    7: .same(proto: "hard"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.topic) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.what) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.delSeq) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._cred) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.hard) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.topic.isEmpty {
      try visitor.visitSingularStringField(value: self.topic, fieldNumber: 2)
    }
    if self.what != .x0 {
      try visitor.visitSingularEnumField(value: self.what, fieldNumber: 3)
    }
    if !self.delSeq.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.delSeq, fieldNumber: 4)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 5)
    }
    try { if let v = self._cred {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if self.hard != false {
      try visitor.visitSingularBoolField(value: self.hard, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbx_ClientDel, rhs: Pbx_ClientDel) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.topic != rhs.topic {return false}
    if lhs.what != rhs.what {return false}
    if lhs.delSeq != rhs.delSeq {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs._cred != rhs._cred {return false}
    if lhs.hard != rhs.hard {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbx_ClientDel.What: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "X0"),
    1: .same(proto: "MSG"),
    2: .same(proto: "TOPIC"),
    3: .same(proto: "SUB"),
    4: .same(proto: "USER"),
    5: .same(proto: "CRED"),
  ]
}

extension Pbx_ClientNote: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClientNote"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topic"),
    2: .same(proto: "what"),
    3: .standard(proto: "seq_id"),
    4: .same(proto: "unread"),
    5: .same(proto: "event"),
    6: .same(proto: "payload"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.topic) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.what) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.seqID) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.unread) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.event) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.payload) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.topic.isEmpty {
      try visitor.visitSingularStringField(value: self.topic, fieldNumber: 1)
    }
    if self.what != .x1 {
      try visitor.visitSingularEnumField(value: self.what, fieldNumber: 2)
    }
    if self.seqID != 0 {
      try visitor.visitSingularInt32Field(value: self.seqID, fieldNumber: 3)
    }
    if self.unread != 0 {
      try visitor.visitSingularInt32Field(value: self.unread, fieldNumber: 4)
    }
    if self.event != .x2 {
      try visitor.visitSingularEnumField(value: self.event, fieldNumber: 5)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbx_ClientNote, rhs: Pbx_ClientNote) -> Bool {
    if lhs.topic != rhs.topic {return false}
    if lhs.what != rhs.what {return false}
    if lhs.seqID != rhs.seqID {return false}
    if lhs.unread != rhs.unread {return false}
    if lhs.event != rhs.event {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbx_ClientExtra: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClientExtra"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "attachments"),
    2: .standard(proto: "on_behalf_of"),
    3: .standard(proto: "auth_level"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.attachments) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.onBehalfOf) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.authLevel) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.attachments.isEmpty {
      try visitor.visitRepeatedStringField(value: self.attachments, fieldNumber: 1)
    }
    if !self.onBehalfOf.isEmpty {
      try visitor.visitSingularStringField(value: self.onBehalfOf, fieldNumber: 2)
    }
    if self.authLevel != .none {
      try visitor.visitSingularEnumField(value: self.authLevel, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbx_ClientExtra, rhs: Pbx_ClientExtra) -> Bool {
    if lhs.attachments != rhs.attachments {return false}
    if lhs.onBehalfOf != rhs.onBehalfOf {return false}
    if lhs.authLevel != rhs.authLevel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbx_ClientMsg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClientMsg"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hi"),
    2: .same(proto: "acc"),
    3: .same(proto: "login"),
    4: .same(proto: "sub"),
    5: .same(proto: "leave"),
    6: .same(proto: "pub"),
    7: .same(proto: "get"),
    8: .same(proto: "set"),
    9: .same(proto: "del"),
    10: .same(proto: "note"),
    13: .same(proto: "extra"),
  ]

  fileprivate class _StorageClass {
    var _message: Pbx_ClientMsg.OneOf_Message?
    var _extra: Pbx_ClientExtra? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _message = source._message
      _extra = source._extra
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try {
          var v: Pbx_ClientHi?
          var hadOneofValue = false
          if let current = _storage._message {
            hadOneofValue = true
            if case .hi(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._message = .hi(v)
          }
        }()
        case 2: try {
          var v: Pbx_ClientAcc?
          var hadOneofValue = false
          if let current = _storage._message {
            hadOneofValue = true
            if case .acc(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._message = .acc(v)
          }
        }()
        case 3: try {
          var v: Pbx_ClientLogin?
          var hadOneofValue = false
          if let current = _storage._message {
            hadOneofValue = true
            if case .login(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._message = .login(v)
          }
        }()
        case 4: try {
          var v: Pbx_ClientSub?
          var hadOneofValue = false
          if let current = _storage._message {
            hadOneofValue = true
            if case .sub(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._message = .sub(v)
          }
        }()
        case 5: try {
          var v: Pbx_ClientLeave?
          var hadOneofValue = false
          if let current = _storage._message {
            hadOneofValue = true
            if case .leave(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._message = .leave(v)
          }
        }()
        case 6: try {
          var v: Pbx_ClientPub?
          var hadOneofValue = false
          if let current = _storage._message {
            hadOneofValue = true
            if case .pub(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._message = .pub(v)
          }
        }()
        case 7: try {
          var v: Pbx_ClientGet?
          var hadOneofValue = false
          if let current = _storage._message {
            hadOneofValue = true
            if case .get(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._message = .get(v)
          }
        }()
        case 8: try {
          var v: Pbx_ClientSet?
          var hadOneofValue = false
          if let current = _storage._message {
            hadOneofValue = true
            if case .set(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._message = .set(v)
          }
        }()
        case 9: try {
          var v: Pbx_ClientDel?
          var hadOneofValue = false
          if let current = _storage._message {
            hadOneofValue = true
            if case .del(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._message = .del(v)
          }
        }()
        case 10: try {
          var v: Pbx_ClientNote?
          var hadOneofValue = false
          if let current = _storage._message {
            hadOneofValue = true
            if case .note(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._message = .note(v)
          }
        }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._extra) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      switch _storage._message {
      case .hi?: try {
        guard case .hi(let v)? = _storage._message else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }()
      case .acc?: try {
        guard case .acc(let v)? = _storage._message else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }()
      case .login?: try {
        guard case .login(let v)? = _storage._message else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }()
      case .sub?: try {
        guard case .sub(let v)? = _storage._message else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      case .leave?: try {
        guard case .leave(let v)? = _storage._message else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case .pub?: try {
        guard case .pub(let v)? = _storage._message else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }()
      case .get?: try {
        guard case .get(let v)? = _storage._message else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }()
      case .set?: try {
        guard case .set(let v)? = _storage._message else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }()
      case .del?: try {
        guard case .del(let v)? = _storage._message else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }()
      case .note?: try {
        guard case .note(let v)? = _storage._message else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }()
      case nil: break
      }
      try { if let v = _storage._extra {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbx_ClientMsg, rhs: Pbx_ClientMsg) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._message != rhs_storage._message {return false}
        if _storage._extra != rhs_storage._extra {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbx_ServerCred: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ServerCred"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "method"),
    2: .same(proto: "value"),
    3: .same(proto: "done"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.method) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.done) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.method.isEmpty {
      try visitor.visitSingularStringField(value: self.method, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    if self.done != false {
      try visitor.visitSingularBoolField(value: self.done, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbx_ServerCred, rhs: Pbx_ServerCred) -> Bool {
    if lhs.method != rhs.method {return false}
    if lhs.value != rhs.value {return false}
    if lhs.done != rhs.done {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbx_TopicDesc: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TopicDesc"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "created_at"),
    2: .standard(proto: "updated_at"),
    3: .standard(proto: "touched_at"),
    4: .same(proto: "defacs"),
    5: .same(proto: "acs"),
    6: .standard(proto: "seq_id"),
    7: .standard(proto: "read_id"),
    8: .standard(proto: "recv_id"),
    9: .standard(proto: "del_id"),
    10: .same(proto: "public"),
    11: .same(proto: "private"),
    12: .same(proto: "state"),
    13: .standard(proto: "state_at"),
    14: .same(proto: "trusted"),
    17: .standard(proto: "is_chan"),
    18: .same(proto: "online"),
    15: .standard(proto: "last_seen_time"),
    16: .standard(proto: "last_seen_user_agent"),
  ]

  fileprivate class _StorageClass {
    var _createdAt: Int64 = 0
    var _updatedAt: Int64 = 0
    var _touchedAt: Int64 = 0
    var _defacs: Pbx_DefaultAcsMode? = nil
    var _acs: Pbx_AccessMode? = nil
    var _seqID: Int32 = 0
    var _readID: Int32 = 0
    var _recvID: Int32 = 0
    var _delID: Int32 = 0
    var _public: Data = Data()
    var _private: Data = Data()
    var _state: String = String()
    var _stateAt: Int64 = 0
    var _trusted: Data = Data()
    var _isChan: Bool = false
    var _online: Bool = false
    var _lastSeenTime: Int64 = 0
    var _lastSeenUserAgent: String = String()

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _createdAt = source._createdAt
      _updatedAt = source._updatedAt
      _touchedAt = source._touchedAt
      _defacs = source._defacs
      _acs = source._acs
      _seqID = source._seqID
      _readID = source._readID
      _recvID = source._recvID
      _delID = source._delID
      _public = source._public
      _private = source._private
      _state = source._state
      _stateAt = source._stateAt
      _trusted = source._trusted
      _isChan = source._isChan
      _online = source._online
      _lastSeenTime = source._lastSeenTime
      _lastSeenUserAgent = source._lastSeenUserAgent
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt64Field(value: &_storage._createdAt) }()
        case 2: try { try decoder.decodeSingularInt64Field(value: &_storage._updatedAt) }()
        case 3: try { try decoder.decodeSingularInt64Field(value: &_storage._touchedAt) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._defacs) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._acs) }()
        case 6: try { try decoder.decodeSingularInt32Field(value: &_storage._seqID) }()
        case 7: try { try decoder.decodeSingularInt32Field(value: &_storage._readID) }()
        case 8: try { try decoder.decodeSingularInt32Field(value: &_storage._recvID) }()
        case 9: try { try decoder.decodeSingularInt32Field(value: &_storage._delID) }()
        case 10: try { try decoder.decodeSingularBytesField(value: &_storage._public) }()
        case 11: try { try decoder.decodeSingularBytesField(value: &_storage._private) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._state) }()
        case 13: try { try decoder.decodeSingularInt64Field(value: &_storage._stateAt) }()
        case 14: try { try decoder.decodeSingularBytesField(value: &_storage._trusted) }()
        case 15: try { try decoder.decodeSingularInt64Field(value: &_storage._lastSeenTime) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._lastSeenUserAgent) }()
        case 17: try { try decoder.decodeSingularBoolField(value: &_storage._isChan) }()
        case 18: try { try decoder.decodeSingularBoolField(value: &_storage._online) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._createdAt != 0 {
        try visitor.visitSingularInt64Field(value: _storage._createdAt, fieldNumber: 1)
      }
      if _storage._updatedAt != 0 {
        try visitor.visitSingularInt64Field(value: _storage._updatedAt, fieldNumber: 2)
      }
      if _storage._touchedAt != 0 {
        try visitor.visitSingularInt64Field(value: _storage._touchedAt, fieldNumber: 3)
      }
      try { if let v = _storage._defacs {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._acs {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if _storage._seqID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._seqID, fieldNumber: 6)
      }
      if _storage._readID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._readID, fieldNumber: 7)
      }
      if _storage._recvID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._recvID, fieldNumber: 8)
      }
      if _storage._delID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._delID, fieldNumber: 9)
      }
      if !_storage._public.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._public, fieldNumber: 10)
      }
      if !_storage._private.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._private, fieldNumber: 11)
      }
      if !_storage._state.isEmpty {
        try visitor.visitSingularStringField(value: _storage._state, fieldNumber: 12)
      }
      if _storage._stateAt != 0 {
        try visitor.visitSingularInt64Field(value: _storage._stateAt, fieldNumber: 13)
      }
      if !_storage._trusted.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._trusted, fieldNumber: 14)
      }
      if _storage._lastSeenTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._lastSeenTime, fieldNumber: 15)
      }
      if !_storage._lastSeenUserAgent.isEmpty {
        try visitor.visitSingularStringField(value: _storage._lastSeenUserAgent, fieldNumber: 16)
      }
      if _storage._isChan != false {
        try visitor.visitSingularBoolField(value: _storage._isChan, fieldNumber: 17)
      }
      if _storage._online != false {
        try visitor.visitSingularBoolField(value: _storage._online, fieldNumber: 18)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbx_TopicDesc, rhs: Pbx_TopicDesc) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._updatedAt != rhs_storage._updatedAt {return false}
        if _storage._touchedAt != rhs_storage._touchedAt {return false}
        if _storage._defacs != rhs_storage._defacs {return false}
        if _storage._acs != rhs_storage._acs {return false}
        if _storage._seqID != rhs_storage._seqID {return false}
        if _storage._readID != rhs_storage._readID {return false}
        if _storage._recvID != rhs_storage._recvID {return false}
        if _storage._delID != rhs_storage._delID {return false}
        if _storage._public != rhs_storage._public {return false}
        if _storage._private != rhs_storage._private {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._stateAt != rhs_storage._stateAt {return false}
        if _storage._trusted != rhs_storage._trusted {return false}
        if _storage._isChan != rhs_storage._isChan {return false}
        if _storage._online != rhs_storage._online {return false}
        if _storage._lastSeenTime != rhs_storage._lastSeenTime {return false}
        if _storage._lastSeenUserAgent != rhs_storage._lastSeenUserAgent {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbx_TopicSub: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TopicSub"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "updated_at"),
    2: .standard(proto: "deleted_at"),
    3: .same(proto: "online"),
    4: .same(proto: "acs"),
    5: .standard(proto: "read_id"),
    6: .standard(proto: "recv_id"),
    7: .same(proto: "public"),
    16: .same(proto: "trusted"),
    8: .same(proto: "private"),
    9: .standard(proto: "user_id"),
    10: .same(proto: "topic"),
    11: .standard(proto: "touched_at"),
    12: .standard(proto: "seq_id"),
    13: .standard(proto: "del_id"),
    14: .standard(proto: "last_seen_time"),
    15: .standard(proto: "last_seen_user_agent"),
  ]

  fileprivate class _StorageClass {
    var _updatedAt: Int64 = 0
    var _deletedAt: Int64 = 0
    var _online: Bool = false
    var _acs: Pbx_AccessMode? = nil
    var _readID: Int32 = 0
    var _recvID: Int32 = 0
    var _public: Data = Data()
    var _trusted: Data = Data()
    var _private: Data = Data()
    var _userID: String = String()
    var _topic: String = String()
    var _touchedAt: Int64 = 0
    var _seqID: Int32 = 0
    var _delID: Int32 = 0
    var _lastSeenTime: Int64 = 0
    var _lastSeenUserAgent: String = String()

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _updatedAt = source._updatedAt
      _deletedAt = source._deletedAt
      _online = source._online
      _acs = source._acs
      _readID = source._readID
      _recvID = source._recvID
      _public = source._public
      _trusted = source._trusted
      _private = source._private
      _userID = source._userID
      _topic = source._topic
      _touchedAt = source._touchedAt
      _seqID = source._seqID
      _delID = source._delID
      _lastSeenTime = source._lastSeenTime
      _lastSeenUserAgent = source._lastSeenUserAgent
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt64Field(value: &_storage._updatedAt) }()
        case 2: try { try decoder.decodeSingularInt64Field(value: &_storage._deletedAt) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._online) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._acs) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._readID) }()
        case 6: try { try decoder.decodeSingularInt32Field(value: &_storage._recvID) }()
        case 7: try { try decoder.decodeSingularBytesField(value: &_storage._public) }()
        case 8: try { try decoder.decodeSingularBytesField(value: &_storage._private) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._userID) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._topic) }()
        case 11: try { try decoder.decodeSingularInt64Field(value: &_storage._touchedAt) }()
        case 12: try { try decoder.decodeSingularInt32Field(value: &_storage._seqID) }()
        case 13: try { try decoder.decodeSingularInt32Field(value: &_storage._delID) }()
        case 14: try { try decoder.decodeSingularInt64Field(value: &_storage._lastSeenTime) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._lastSeenUserAgent) }()
        case 16: try { try decoder.decodeSingularBytesField(value: &_storage._trusted) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._updatedAt != 0 {
        try visitor.visitSingularInt64Field(value: _storage._updatedAt, fieldNumber: 1)
      }
      if _storage._deletedAt != 0 {
        try visitor.visitSingularInt64Field(value: _storage._deletedAt, fieldNumber: 2)
      }
      if _storage._online != false {
        try visitor.visitSingularBoolField(value: _storage._online, fieldNumber: 3)
      }
      try { if let v = _storage._acs {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if _storage._readID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._readID, fieldNumber: 5)
      }
      if _storage._recvID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._recvID, fieldNumber: 6)
      }
      if !_storage._public.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._public, fieldNumber: 7)
      }
      if !_storage._private.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._private, fieldNumber: 8)
      }
      if !_storage._userID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._userID, fieldNumber: 9)
      }
      if !_storage._topic.isEmpty {
        try visitor.visitSingularStringField(value: _storage._topic, fieldNumber: 10)
      }
      if _storage._touchedAt != 0 {
        try visitor.visitSingularInt64Field(value: _storage._touchedAt, fieldNumber: 11)
      }
      if _storage._seqID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._seqID, fieldNumber: 12)
      }
      if _storage._delID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._delID, fieldNumber: 13)
      }
      if _storage._lastSeenTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._lastSeenTime, fieldNumber: 14)
      }
      if !_storage._lastSeenUserAgent.isEmpty {
        try visitor.visitSingularStringField(value: _storage._lastSeenUserAgent, fieldNumber: 15)
      }
      if !_storage._trusted.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._trusted, fieldNumber: 16)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbx_TopicSub, rhs: Pbx_TopicSub) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._updatedAt != rhs_storage._updatedAt {return false}
        if _storage._deletedAt != rhs_storage._deletedAt {return false}
        if _storage._online != rhs_storage._online {return false}
        if _storage._acs != rhs_storage._acs {return false}
        if _storage._readID != rhs_storage._readID {return false}
        if _storage._recvID != rhs_storage._recvID {return false}
        if _storage._public != rhs_storage._public {return false}
        if _storage._trusted != rhs_storage._trusted {return false}
        if _storage._private != rhs_storage._private {return false}
        if _storage._userID != rhs_storage._userID {return false}
        if _storage._topic != rhs_storage._topic {return false}
        if _storage._touchedAt != rhs_storage._touchedAt {return false}
        if _storage._seqID != rhs_storage._seqID {return false}
        if _storage._delID != rhs_storage._delID {return false}
        if _storage._lastSeenTime != rhs_storage._lastSeenTime {return false}
        if _storage._lastSeenUserAgent != rhs_storage._lastSeenUserAgent {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbx_DelValues: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DelValues"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "del_id"),
    2: .standard(proto: "del_seq"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.delID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.delSeq) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.delID != 0 {
      try visitor.visitSingularInt32Field(value: self.delID, fieldNumber: 1)
    }
    if !self.delSeq.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.delSeq, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbx_DelValues, rhs: Pbx_DelValues) -> Bool {
    if lhs.delID != rhs.delID {return false}
    if lhs.delSeq != rhs.delSeq {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbx_ServerCtrl: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ServerCtrl"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "topic"),
    3: .same(proto: "code"),
    4: .same(proto: "text"),
    5: .same(proto: "params"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.topic) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufBytes>.self, value: &self.params) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.topic.isEmpty {
      try visitor.visitSingularStringField(value: self.topic, fieldNumber: 2)
    }
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 3)
    }
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 4)
    }
    if !self.params.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufBytes>.self, value: self.params, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbx_ServerCtrl, rhs: Pbx_ServerCtrl) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.topic != rhs.topic {return false}
    if lhs.code != rhs.code {return false}
    if lhs.text != rhs.text {return false}
    if lhs.params != rhs.params {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbx_ServerData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ServerData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topic"),
    2: .standard(proto: "from_user_id"),
    7: .same(proto: "timestamp"),
    3: .standard(proto: "deleted_at"),
    4: .standard(proto: "seq_id"),
    5: .same(proto: "head"),
    6: .same(proto: "content"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.topic) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.fromUserID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.deletedAt) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.seqID) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufBytes>.self, value: &self.head) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.content) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.topic.isEmpty {
      try visitor.visitSingularStringField(value: self.topic, fieldNumber: 1)
    }
    if !self.fromUserID.isEmpty {
      try visitor.visitSingularStringField(value: self.fromUserID, fieldNumber: 2)
    }
    if self.deletedAt != 0 {
      try visitor.visitSingularInt64Field(value: self.deletedAt, fieldNumber: 3)
    }
    if self.seqID != 0 {
      try visitor.visitSingularInt32Field(value: self.seqID, fieldNumber: 4)
    }
    if !self.head.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufBytes>.self, value: self.head, fieldNumber: 5)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularBytesField(value: self.content, fieldNumber: 6)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbx_ServerData, rhs: Pbx_ServerData) -> Bool {
    if lhs.topic != rhs.topic {return false}
    if lhs.fromUserID != rhs.fromUserID {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.deletedAt != rhs.deletedAt {return false}
    if lhs.seqID != rhs.seqID {return false}
    if lhs.head != rhs.head {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbx_ServerPres: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ServerPres"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topic"),
    2: .same(proto: "src"),
    3: .same(proto: "what"),
    4: .standard(proto: "user_agent"),
    5: .standard(proto: "seq_id"),
    6: .standard(proto: "del_id"),
    7: .standard(proto: "del_seq"),
    8: .standard(proto: "target_user_id"),
    9: .standard(proto: "actor_user_id"),
    10: .same(proto: "acs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.topic) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.src) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.what) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.userAgent) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.seqID) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.delID) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.delSeq) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.targetUserID) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.actorUserID) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._acs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.topic.isEmpty {
      try visitor.visitSingularStringField(value: self.topic, fieldNumber: 1)
    }
    if !self.src.isEmpty {
      try visitor.visitSingularStringField(value: self.src, fieldNumber: 2)
    }
    if self.what != .x3 {
      try visitor.visitSingularEnumField(value: self.what, fieldNumber: 3)
    }
    if !self.userAgent.isEmpty {
      try visitor.visitSingularStringField(value: self.userAgent, fieldNumber: 4)
    }
    if self.seqID != 0 {
      try visitor.visitSingularInt32Field(value: self.seqID, fieldNumber: 5)
    }
    if self.delID != 0 {
      try visitor.visitSingularInt32Field(value: self.delID, fieldNumber: 6)
    }
    if !self.delSeq.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.delSeq, fieldNumber: 7)
    }
    if !self.targetUserID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetUserID, fieldNumber: 8)
    }
    if !self.actorUserID.isEmpty {
      try visitor.visitSingularStringField(value: self.actorUserID, fieldNumber: 9)
    }
    try { if let v = self._acs {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbx_ServerPres, rhs: Pbx_ServerPres) -> Bool {
    if lhs.topic != rhs.topic {return false}
    if lhs.src != rhs.src {return false}
    if lhs.what != rhs.what {return false}
    if lhs.userAgent != rhs.userAgent {return false}
    if lhs.seqID != rhs.seqID {return false}
    if lhs.delID != rhs.delID {return false}
    if lhs.delSeq != rhs.delSeq {return false}
    if lhs.targetUserID != rhs.targetUserID {return false}
    if lhs.actorUserID != rhs.actorUserID {return false}
    if lhs._acs != rhs._acs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbx_ServerPres.What: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "X3"),
    1: .same(proto: "ON"),
    2: .same(proto: "OFF"),
    3: .same(proto: "UA"),
    4: .same(proto: "UPD"),
    5: .same(proto: "GONE"),
    6: .same(proto: "ACS"),
    7: .same(proto: "TERM"),
    8: .same(proto: "MSG"),
    9: .same(proto: "READ"),
    10: .same(proto: "RECV"),
    11: .same(proto: "DEL"),
    12: .same(proto: "TAGS"),
  ]
}

extension Pbx_ServerMeta: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ServerMeta"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "topic"),
    3: .same(proto: "desc"),
    4: .same(proto: "sub"),
    5: .same(proto: "del"),
    6: .same(proto: "tags"),
    7: .same(proto: "cred"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.topic) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._desc) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.sub) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._del) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.tags) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.cred) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.topic.isEmpty {
      try visitor.visitSingularStringField(value: self.topic, fieldNumber: 2)
    }
    try { if let v = self._desc {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.sub.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sub, fieldNumber: 4)
    }
    try { if let v = self._del {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.tags.isEmpty {
      try visitor.visitRepeatedStringField(value: self.tags, fieldNumber: 6)
    }
    if !self.cred.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cred, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbx_ServerMeta, rhs: Pbx_ServerMeta) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.topic != rhs.topic {return false}
    if lhs._desc != rhs._desc {return false}
    if lhs.sub != rhs.sub {return false}
    if lhs._del != rhs._del {return false}
    if lhs.tags != rhs.tags {return false}
    if lhs.cred != rhs.cred {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbx_ServerInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ServerInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topic"),
    2: .standard(proto: "from_user_id"),
    3: .same(proto: "what"),
    4: .standard(proto: "seq_id"),
    5: .same(proto: "src"),
    6: .same(proto: "event"),
    7: .same(proto: "payload"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.topic) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.fromUserID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.what) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.seqID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.src) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.event) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.payload) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.topic.isEmpty {
      try visitor.visitSingularStringField(value: self.topic, fieldNumber: 1)
    }
    if !self.fromUserID.isEmpty {
      try visitor.visitSingularStringField(value: self.fromUserID, fieldNumber: 2)
    }
    if self.what != .x1 {
      try visitor.visitSingularEnumField(value: self.what, fieldNumber: 3)
    }
    if self.seqID != 0 {
      try visitor.visitSingularInt32Field(value: self.seqID, fieldNumber: 4)
    }
    if !self.src.isEmpty {
      try visitor.visitSingularStringField(value: self.src, fieldNumber: 5)
    }
    if self.event != .x2 {
      try visitor.visitSingularEnumField(value: self.event, fieldNumber: 6)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbx_ServerInfo, rhs: Pbx_ServerInfo) -> Bool {
    if lhs.topic != rhs.topic {return false}
    if lhs.fromUserID != rhs.fromUserID {return false}
    if lhs.what != rhs.what {return false}
    if lhs.seqID != rhs.seqID {return false}
    if lhs.src != rhs.src {return false}
    if lhs.event != rhs.event {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbx_ServerMsg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ServerMsg"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ctrl"),
    2: .same(proto: "data"),
    3: .same(proto: "pres"),
    4: .same(proto: "meta"),
    5: .same(proto: "info"),
    6: .same(proto: "topic"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Pbx_ServerCtrl?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .ctrl(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .ctrl(v)
        }
      }()
      case 2: try {
        var v: Pbx_ServerData?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .data(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .data(v)
        }
      }()
      case 3: try {
        var v: Pbx_ServerPres?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .pres(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .pres(v)
        }
      }()
      case 4: try {
        var v: Pbx_ServerMeta?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .meta(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .meta(v)
        }
      }()
      case 5: try {
        var v: Pbx_ServerInfo?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .info(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .info(v)
        }
      }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.topic) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.message {
    case .ctrl?: try {
      guard case .ctrl(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .data?: try {
      guard case .data(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .pres?: try {
      guard case .pres(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .meta?: try {
      guard case .meta(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .info?: try {
      guard case .info(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    if !self.topic.isEmpty {
      try visitor.visitSingularStringField(value: self.topic, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbx_ServerMsg, rhs: Pbx_ServerMsg) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.topic != rhs.topic {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbx_ServerResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ServerResp"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "srvmsg"),
    3: .same(proto: "clmsg"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._srvmsg) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._clmsg) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.status != .continue {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    try { if let v = self._srvmsg {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._clmsg {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbx_ServerResp, rhs: Pbx_ServerResp) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs._srvmsg != rhs._srvmsg {return false}
    if lhs._clmsg != rhs._clmsg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbx_Session: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Session"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "session_id"),
    2: .standard(proto: "user_id"),
    3: .standard(proto: "auth_level"),
    4: .standard(proto: "remote_addr"),
    5: .standard(proto: "user_agent"),
    6: .standard(proto: "device_id"),
    7: .same(proto: "language"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.authLevel) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.remoteAddr) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.userAgent) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.language) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 1)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 2)
    }
    if self.authLevel != .none {
      try visitor.visitSingularEnumField(value: self.authLevel, fieldNumber: 3)
    }
    if !self.remoteAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.remoteAddr, fieldNumber: 4)
    }
    if !self.userAgent.isEmpty {
      try visitor.visitSingularStringField(value: self.userAgent, fieldNumber: 5)
    }
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 6)
    }
    if !self.language.isEmpty {
      try visitor.visitSingularStringField(value: self.language, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbx_Session, rhs: Pbx_Session) -> Bool {
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.authLevel != rhs.authLevel {return false}
    if lhs.remoteAddr != rhs.remoteAddr {return false}
    if lhs.userAgent != rhs.userAgent {return false}
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.language != rhs.language {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbx_ClientReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClientReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "msg"),
    2: .same(proto: "sess"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._msg) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._sess) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._msg {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._sess {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbx_ClientReq, rhs: Pbx_ClientReq) -> Bool {
    if lhs._msg != rhs._msg {return false}
    if lhs._sess != rhs._sess {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbx_SearchQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchQuery"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .same(proto: "query"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.query) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if !self.query.isEmpty {
      try visitor.visitSingularStringField(value: self.query, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbx_SearchQuery, rhs: Pbx_SearchQuery) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.query != rhs.query {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbx_SearchFound: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchFound"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "query"),
    3: .same(proto: "result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.query) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .continue {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    if !self.query.isEmpty {
      try visitor.visitSingularStringField(value: self.query, fieldNumber: 2)
    }
    if !self.result.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.result, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbx_SearchFound, rhs: Pbx_SearchFound) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.query != rhs.query {return false}
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbx_TopicEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TopicEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .same(proto: "name"),
    3: .same(proto: "desc"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._desc) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.action != .create {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try { if let v = self._desc {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbx_TopicEvent, rhs: Pbx_TopicEvent) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.name != rhs.name {return false}
    if lhs._desc != rhs._desc {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbx_AccountEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccountEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .standard(proto: "user_id"),
    3: .standard(proto: "default_acs"),
    4: .same(proto: "public"),
    8: .same(proto: "tags"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._defaultAcs) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.`public`) }()
      case 8: try { try decoder.decodeRepeatedStringField(value: &self.tags) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.action != .create {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 1)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 2)
    }
    try { if let v = self._defaultAcs {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.`public`.isEmpty {
      try visitor.visitSingularBytesField(value: self.`public`, fieldNumber: 4)
    }
    if !self.tags.isEmpty {
      try visitor.visitRepeatedStringField(value: self.tags, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbx_AccountEvent, rhs: Pbx_AccountEvent) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs._defaultAcs != rhs._defaultAcs {return false}
    if lhs.`public` != rhs.`public` {return false}
    if lhs.tags != rhs.tags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbx_SubscriptionEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscriptionEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .same(proto: "topic"),
    3: .standard(proto: "user_id"),
    4: .standard(proto: "del_id"),
    5: .standard(proto: "read_id"),
    6: .standard(proto: "recv_id"),
    7: .same(proto: "mode"),
    8: .same(proto: "private"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.topic) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.delID) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.readID) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.recvID) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._mode) }()
      case 8: try { try decoder.decodeSingularBytesField(value: &self.`private`) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.action != .create {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 1)
    }
    if !self.topic.isEmpty {
      try visitor.visitSingularStringField(value: self.topic, fieldNumber: 2)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 3)
    }
    if self.delID != 0 {
      try visitor.visitSingularInt32Field(value: self.delID, fieldNumber: 4)
    }
    if self.readID != 0 {
      try visitor.visitSingularInt32Field(value: self.readID, fieldNumber: 5)
    }
    if self.recvID != 0 {
      try visitor.visitSingularInt32Field(value: self.recvID, fieldNumber: 6)
    }
    try { if let v = self._mode {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if !self.`private`.isEmpty {
      try visitor.visitSingularBytesField(value: self.`private`, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbx_SubscriptionEvent, rhs: Pbx_SubscriptionEvent) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.topic != rhs.topic {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.delID != rhs.delID {return false}
    if lhs.readID != rhs.readID {return false}
    if lhs.recvID != rhs.recvID {return false}
    if lhs._mode != rhs._mode {return false}
    if lhs.`private` != rhs.`private` {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbx_MessageEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MessageEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .same(proto: "msg"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._msg) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.action != .create {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 1)
    }
    try { if let v = self._msg {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbx_MessageEvent, rhs: Pbx_MessageEvent) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs._msg != rhs._msg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
